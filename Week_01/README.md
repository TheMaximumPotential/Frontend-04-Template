### 井字棋

> 我是先用自己的方法取实现井字棋的，不加 AI 之前都没有出什么很大的问题，但是加 AI 的时候真是一步一个坑

1. **check** 函数是检测游戏是否结束，我自以为没有什么问题，在游戏运行过程中，横向棋盘连城三子却没有结束游戏，原因出在我检测横排时遇到不一样的就直接 break 了，应该使用 continue 跳向下一行。

```js
// 横向
row: for (i = 0; i < 3; ++i) {
	piece = checkerboard[i][0]
	for (j = 0; j < 3; ++j) {
		if (!checkerboard[i][j]) continue row
		if (piece !== checkerboard[i][j]) continue row
		if (j === 2) return normalize(true, piece)
	}
}
```

2. 还有 **check** 函数的返回值我做了特殊处理，殊不知也是给自己挖坑...就是下面这个**normalize**函数，返回的结构都是如果有赢家则返回 **state** 为 **true**，**winner** 为胜者棋子，但是棋盘满了之后返回的 **state** 也是 **true**，应为游戏结束，但是没有 **winner**，后面判断时候最后一个子赢了也判断成棋盘满了的平局。

```js
const normalize = (state = false, winner = '') => ({ state, winner })
```

3. 到了 **willWin** 函数应为上两个函数的问题，总跑不出想要的结果，跑着跑着就报错，所以我单把错误数据拿了出来做测试，下面这些数据跑通了，这个函数也就没问题了。

```js
let checkerboard = [
	[0, 0, 0],
	[0, 0, 0],
	[0, 0, 0],
]
// let checkerboard = [
//     ['x', 'o', 'x'],
//     ['o', 'o', 0],
//     ['o', 'x', 0]
// ]
// let checkerboard = [
//     ["x", 0, "o"],
//     ["o", "o", "x"],
//     ["x", 0, 0]
// ]
// let checkerboard = [
//     ["x", 'x', "o"],
//     ["o", "o", "x"],
//     ["x", "o", 0]
// ]
```

4. 最难理解的 **bestChoice** 函数，大致思路按就是每下一个子，就遍历跑完棋盘上所有没有下棋的地方，然后找出下一颗子最佳的落点，每个落子的地方分三个级别，如果我是电脑，首先要选则第一级别，就是下完就能赢的地方，第二级别是，如果不能一下赢，那要保证自己不会输，也就是堵住对方能赢的地方，第三个级别就是，下这里必输。
    > 核心：此时我是个 AI，当玩家落子之后，我会在棋盘每个地方下一颗子，之后利用递归，我会模拟玩家又走了下一步，之后我再下一步（这里都是我和我自己下的棋），直到模拟这局游戏结束，如果遍历过程中找到一级落子点，则我就赢了，不用往下进行递归，如果所有情况遍历完只找到了二级落子点，则现在要去寻找玩家有没有一级落子点，保证我不会输，如果只找到三级落子点，那么我输了（输了就不是一个好 AI，重新写代码）

```js
// 核心代码：r.result如果等于-1 则用户是必输的，所以我们一定要下这个点，如果r.result是0，则没有决胜点，呢么就在找到的二级点下，如果r.result等于1，那么用户赢了你就重新写代码吧
temp[i][j] = step % 2 === 0 ? 'o' : 'x'
let r = bestChoice(temp, step + 1)
if (-r.result >= result) {
	// console.log(result, r)
	result = -r.result
	computerDrop = { i, j }
}
```
